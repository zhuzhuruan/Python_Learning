# -*- coding:utf-8 -*-
""""""
"""
-------------------------------------------------import-------------------------------------------------
一、什么是模块
1、定义：模块就是一系列功能的集合体
        在Python中，一个py文件就是一个模块，文件名为xxx.py模块名则是xxx,导入模块可以引用模块中已经写好的功能。   

2、来源
    （1）内置模块
    （2）第三方模块
    （3）自定义模块

3、分类
    （1）使用纯Python代码编写的py文件
    （2）已被编译为共享库或DDL的C或C++扩展
    （3）把一系列模块组织到一起的文件夹（注：文件夹下有一个__init__.py文件，该文件夹称之为包）
    （4）使用C编写并链接到Python解释器中的内置模块


二、为什么要有模块
    1、内置模块和第三方模块拿来就用，无需定义，拿来主义，可以极大地提升开发效率
    2、可以将程序的部分功能提取出来放到模块中共享使用，可以减少代码冗余
    
    
三、如何使用模块（以foo模块为例）
1、首次导入模块发生的三件事
    （1）执行foo.py文件
    （2）产生foo.py的名称空间，将foo.py运行过程中产生的名字都丢到foo的名称空间中
    （3）在当前文件中产生一个名字为foo,改名字指向（2）中产生的名称空间
   之后再导入模块，都是直接引用首次导入的foo.py的名称空间，不会重复执行代码 
    
2、引用
    （1）模块名.函数名：指名道姓的像某个模块要某个功能，不会与当前的名称空间中的名字发生冲突    
    
                import practice_file.foo
                print(practice_file.foo.x)
                print(practice_file.foo.get)
                print(practice_file.foo.change)
    
    （2）无论是查看还是修改都是模块本身（定义阶段），与调用位置无关
                import practice_file.foo
                x = 1111
                practice_file.foo.get()       # 打印的x是模块中定义的x
                
                practice_file.foo.change()   
                print(practice_file.foo.x)    # 模块中的x被修改
                print(x)                
                  
    （3）可以以逗号为分隔符导入多个模块（不建议）
    
    （4）导入模块的规范：导入先后顺序
            <1> Python内置模块
            <2> 第三方模块
            <3> 自定义模块          
            
    （5）import ... as ...:可以为导入的模块定义别名
            import practice_file.foo as test
            
    （6）自定义模块的命名应该采用纯小写+下划线的风格    
    
    （7）可以在函数内导入模块
        def func():
            import ...
          
          
四、import导入模块的优缺点
1、优点：不会与当前名称空间中的变量名称冲突
2、缺点：加前缀比较麻烦
       
       
-------------------------------------------------python文件的两种用途-------------------------------------------------
 # 两种用途
        # 作为程序运行
        # 作为模块导入       
          
# 案例理解: run.py、foo.py

            模块foo的名称空间                      run.py程序的名称空间
          ----------------------              ------------------------      
          ¦    x -> 222内存地址  ¦              ¦     x -> 111内存地址  ¦
          ¦                    ¦              ¦                      ¦
          ¦   get -> 内存地址    ¦ <------------¦--------foo           ¦
          ¦                    ¦              ¦                      ¦
          ¦  change -> 内存地址  ¦              ¦                      ¦
          ¦                    ¦               ¦                     ¦
          ¦                    ¦               ¦                     ¦
          ---------------------                ----------------------- 

# 当py文件作为模块使用前，它本身也是一个可以作为程序执行的文件，例如foo.py中"get()和change()"有这两行代码，执行foo.py就可以把它作为程序直接用
  当它作为模块使用时，import foo这一步首先就要执行foo文件，但是当foo文件是作为模块导入使用时，并不希望执行文件中的调用代码，如何实现呢？
  
  直接执行foo.py文件，print(__name__)的值是__main__
  import foo，print(foo.__name__)的值是模块名foo
  所以在foo.py文件中，调用代码可以写成：
        if __name__ == '__main__':      # 直接执行foo要做的事情
            get()
            change()
        else:                           # 作为模块导入要做的事情(省略不写)
            pass
            
  
        
-------------------------------------------------from...import-------------------------------------------------
1、使用from...import导入模块发生的三件事：
    （1）执行foo.py文件
    （2）产生foo.py的名称空间，将foo.py运行过程中产生的名字都丢到foo的名称空间中
    （3）在当前名称空间拿到一个名字，该名字指向模块名称空间的某个内存地址
    
            模块foo的名称空间                      run.py程序的名称空间
          ----------------------              ------------------------      
          ¦    x -> 222内存地址  ¦<------------¦-----x -> 内存地址      ¦
          ¦                    ¦              ¦                      ¦
          ¦   get -> 内存地址    ¦ <------------¦-----get -> 内存地址   ¦
          ¦                    ¦               ¦                     ¦
          ¦  change -> 内存地址  ¦ <-------------¦----change -> 内存地址¦
          ¦                    ¦               ¦                     ¦
          ¦                    ¦               ¦                     ¦
          ---------------------                ----------------------- 


2、优缺点：from...import...导入模块在使用时不用加前缀
    （1）优点：代码更精简
    （2）容易与当前名称空间混淆


3、引用
    （1）可以以逗号为分隔符导入多个模块（不建议）
    （2）from ...import * : 导入模块中的所有名字（不推荐）
    （3）__all__ = []: __all__存放的就是模块中的所有名称空间的名字，修改[]可以控制*导入的变量名字                       
                               
                               
-------------------------------------------------循环导入问题-------------------------------------------------
1、循环导入：循环导入问题指的是在一个模块加载/导入的过程中导入另外一个模块，而在另外一个模块中又返回来导入第一个模块中的名字，
           由于第一个模块尚未加载完毕，所以引用失败、抛出异常，究其根源就是在python中，同一个模块只会在第一次导入时执行其内部代码，
           再次导入该模块时，即便是该模块尚未完全加载完毕也不会去重复执行内部代码
    
2、示例       
    # m1.py

        print('正在导入m1')
        from m2 import y
        x='m1'
        
    # m2.py

        print('正在导入m2')
        from m1 import x
        y='m2'
        
    # run.py

        import m1        
           
 分析：（1）先执行run.py会抛出异常
          先执行run.py--->执行import m1，开始导入m1并运行其内部代码--->打印内容"正在导入m1"
          --->执行from m2 import y 开始导入m2并运行其内部代码--->打印内容“正在导入m2”--->
          执行from m1 import x,由于m1已经被导入过了，所以不会重新导入，所以直接去m1中拿x，然而x此时并没有存在于m1中，所以报错       
             
      （2）先执行m1.py
          执行m1.py，打印“正在导入m1”，执行from m2 import y ，导入m2进而执行m2.py内部代码--->打印"正在导入m2"，执行from m1 import x，
          此时m1是第一次被导入，执行m1.py并不等于导入了m1，于是开始导入m1并执行其内部代码--->打印"正在导入m1"，执行from m2 import y，
          由于m1已经被导入过了，所以无需继续导入而直接问m2要y，然而y此时并没有存在于m2中所以报错     
           
 解决方案
    # 方案一：导入语句放到最后，保证在导入时，所有名字都已经加载过
        # 文件：m1.py
        print('正在导入m1')        
        x='m1'        
        from m2 import y
        
        # 文件：m2.py
        print('正在导入m2')
        y='m2'
        from m1 import x
        
        # 文件：run.py内容如下，执行该文件，可以正常使用
        import m1
        print(m1.x)
        print(m1.y)          
         
    # 方案二：导入语句放到函数中，只有在调用函数时才会执行其内部代码
        # 文件：m1.py
        print('正在导入m1')        
        def f1():
            from m2 import y
            print(x,y)      
        x = 'm1'
        
        # 文件：m2.py
        print('正在导入m2')        
        def f2():
            from m1 import x
            print(x,y)  
        y = 'm2'
        
        # 文件：run.py内容如下，执行该文件，可以正常使用
        import m1
        m1.f1()     
                 
3、注意：循环导入问题大多数情况是因为程序设计失误导致，上述解决方案也只是在烂设计之上的无奈之举，在我们的程序中应该尽量避免出现循环/嵌套导入，
       如果多个模块确实都需要共享某些数据，可以将共享的数据集中存放到某一个地方，然后进行导入         
     
     

-------------------------------------------------模块查找优先级-------------------------------------------------
1、无论是import还是from...import...在导入模块时都涉及到查找问题

2、优先级：在导入一个模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，
         直到找模块对应的文件为止，否则抛出异常。sys.path也被称为模块的搜索路径，它是一个列表类型

    （1）内存（内置模块）
            通过sys.modules查看已经加载到内存中的模块
            
    （2）sys.path中的路径

        ['',
        '/Library/Frameworks/Python.framework/Versions/3.5/lib/python35.zip',
        '/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5',
        ...,
        '/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages'
        ]

        sys.path中的第一个路径通常为空，代表执行文件所在的路径，所以在被导入模块与执行文件在同一目录下时肯定是可以正常导入的，而针对被导入的模块与
        执行文件在不同路径下的情况，为了确保模块对应的源文件仍可以被找到，需要将源文件foo.py所在的路径添加到sys.path中，假设foo.py所在的路径为
        /pythoner/projects/ 
        
            import sys
            sys.path.append(r'/pythoner/projects/')     # 也可以使用sys.path.insert(……)
            import foo          # 无论foo.py在何处,我们都可以导入它了
            
            


-------------------------------------------------编写模块规范-------------------------------------------------
           
    "The module is used to..." #模块的文档描述
    
    import sys #导入模块
    
    x=1 #定义全局变量,如果非必须,则最好使用局部变量,这样可以提高代码的易维护性,并且可以节省内存提高性能
    
    class Foo: #定义类,并写好类的注释
        'Class Foo is used to...'
        pass
    
    def test(): #定义函数,并写好函数的注释
        'Function test is used to…'
        pass
    
    if __name__ == '__main__': #主程序
        test() #在被当做脚本执行时,执行此处的代码
            
            
"""
